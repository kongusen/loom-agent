# 记忆与上下文控制 (Memory & Context Control)

Loom v0.3.6 引入了 "有感知 (Sentient)" 的记忆系统。它超越了简单的滚动窗口，采用模拟生物记忆的 4 层层级结构。

## L1-L4 记忆层级

### L1: 反应性记忆 (Sensory Buffer)
*   **持续时间**: 立即 / 当前轮次。
*   **存储**: RAM (短暂)。
*   **内容**: 原始用户输入，即时的工具输出。
*   **目的**: 在提交前进行即时处理和完整性检查。

### L2: 工作记忆 (Short-Term)
*   **持续时间**: 当前会话 / 任务交互期间。
*   **存储**: Redis / RAM。
*   **内容**: 当前对话线程，活跃目标，最近的工具结果。
*   **目的**: 为手头的即时任务提供上下文。

### L3: 情景记忆 (Episodic - Long-Term History)
*   **持续时间**: 无限期 (数天/数月)。
*   **存储**: 向量数据库 (Qdrant) + SQL/文件。
*   **内容**: 过去会话的摘要，"上周发生了什么"。
*   **目的**: 提供跨会话的连续性。"上次我们要谈到......"

### L4: 语义记忆 (Semantic - Persisted Knowledge)
*   **持续时间**: 永久。
*   **存储**: 向量数据库 (Qdrant)。
*   **内容**: 结晶的事实，用户画像，世界知识。
*   **示例**: "用户是素食主义者", "项目 X 使用 Python 3.11"。
*   **目的**: 个性化体验和深度理解。

## 复合记忆适配器 (Composite Memory Adapter)

系统使用 `CompositeMemory` 适配器来统一这些层级。当 Agent 请求上下文时：

1.  **回忆 (Recall)**: 获取最近的消息 (L2)。
2.  **检索 (Retrieval)**: 根据当前查询向量，在 Qdrant 中搜索相关的情景 (L3) 和语义 (L4) 事实。
3.  **融合 (Fusion)**: 将这些信息组合成单一的 Prompt Context。

## 上下文控制与新陈代谢 (Context Control & Metabolism)

为了防止上下文膨胀（以及高昂的成本），Loom 实施了**新陈代谢生命周期**：

### 1. 摄入 (Ingest / Eat)
新信息进入 L1。经过验证和清洗。

### 2. 消化 (Digest / Process)
信息移动到 L2。如果 L2 满了，**ContextCompressor (上下文压缩器)** 启动。
*   **压缩**: 旧的 L2 消息被总结。
*   **提取**: 关键事实被提取到 L4（例如，"用户更新了偏好 X"）。

### 3. 同化 (Assimilate / Store)
摘要移动到 L3 (情景)。提取的事实移动到 L4 (语义)。原始的 L2 缓冲区被清除或截断。

这确保了发送给 LLM 的 "有效上下文" 始终是**高信号、低噪声**的，并且在不丢失重要长期细节的情况下适应 Token 限制。
