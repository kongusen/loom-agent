# Loom v0.3.6：当我们谈论"有感知"的智能体架构时，我们在谈论什么？

> 写框架的过程，其实是一场关于"什么是 Agent"的持续追问。

## 一、 起点：当理想照进现实

回想起 Loom 早期版本的开发经历，我们一直被两个问题困扰：

**第一个问题**：写死的工作流（Workflow）虽然稳定，但太僵化。用户问个问题，Agent 只能按预设的步骤走，稍微超出一点范围就"傻"了。

**第二个问题**：纯 ReAct 循环虽然灵活，但太不可控。Agent 可能会陷入无限思考循环，Token 账单让人心疼，而且每次调用结果还不稳定。

我们需要的是一个**既能像脚本一样稳定，又能像人类一样灵活**的架构。

这不仅仅是技术选型的问题，而是关于"什么是智能体"的本质思考。经过多次重构，v0.3.6 给出了我们的答案：**一个能够"无限扩张"的生命体架构**。

```
┌─────────────────────────────────────────────┐
│                                             │
│         📐 【图片占位 1】                     │
│                                             │
│      标题：从"僵化的工作流"到"有感知的架构"      │
│                                             │
│      [线框图：左侧是僵硬的直线流程图]          │
│             右侧是类似神经网络的有机结构]      │
│                                             │
│      设计要点：                               │
│      - 左侧：方框+箭头，机械感，冷色调          │
│      - 右侧：节点+网状连接，有机感，暖色调      │
│      - 中间用箭头连接，标注"演进"              │
│                                             │
└─────────────────────────────────────────────┘
```

## 二、 骨架：协议优先与万物皆节点

在传统的 Agent 框架中，Agent、Tool、Chain 往往是割裂的概念。你写了一个 Agent，想把它当成工具在另一个 Agent 里调用？对不起，得写一堆适配器代码。

这种**类继承地狱**让架构变得僵硬。

### 我们的解法：协议优先 (Protocol-First)

v0.3.6 引入了 `NodeProtocol` 和 CloudEvents 标准，核心理念很简单：

> **万物皆节点**

- Agent 是节点
- Tool 是节点
- Crew（多个 Agent 组成的团队）也是节点
- 甚至... 一个 Crew 里面的某个 Agent，本身又包含了一个子 Crew

这就是**无限分形 (Fractal Recursion)** 的威力。Agent A 可以调用 Crew B，Crew B 内部的 Agent C 又可以反过来调用 Agent A。逻辑结构可以像分形几何一样无限嵌套。

```
┌─────────────────────────────────────────────┐
│                                             │
│         📐 【图片占位 2】                     │
│                                             │
│      标题：分形节点架构 (Fractal Node)         │
│                                             │
│      [线框图：展示嵌套结构]                   │
│                                             │
│      设计要点：                               │
│      - 中心：标准的接口形状 (NodeProtocol)    │
│      - 周围连接不同形状：                     │
│        • Agent = 圆形                         │
│        • Tool = 方形                          │
│        • Crew = 六边形                        │
│      - 展示递归包含关系：                     │
│        大六边形(Crew)包含小圆形(Agent)        │
│        小圆形里又有更小的六边形               │
│      - 所有连接线统一为 Event 流，带箭头       │
│      - 配色：科技蓝/紫色渐变                   │
│                                             │
└─────────────────────────────────────────────┘
```

这种架构带来的好处是什么？**组合的自由度**。你可以像搭积木一样，把简单的节点组合成复杂的系统，而整个系统依然遵循同一套通信协议。

## 三、 大脑：快思慢想的双系统

人脑有两套思考系统，这在诺贝尔奖得主丹尼尔·卡尼曼的《思考，快与慢》中有精辟的阐述：

- **System 1**：直觉、快速、自动化
- **System 2**：推理、慢速、需要费力

大多数 Agent 框架的问题在于：**所有请求都走 System 2**。

用户只是想闲聊几句，你的 Agent 却要启动完整的 ReAct 循环：分析意图、规划任务、执行工具、观察结果... 简单问题被复杂化，既慢又贵。

### 我们的解法：认知路由器 (Cognitive Router)

v0.3.6 引入了智能路由机制：

```
用户请求 → 认知路由器 → 判断复杂度 → 选择路径
```

**System 1 路径（快）**：处理闲聊、简单问答、直接查询。就像人类打招呼，不需要思考太多，直接回应。

**System 2 路径（慢）**：处理代码生成、复杂规划、多步任务。启动完整的推理循环。

**这意味着什么？** 在成本、速度和质量之间取得动态平衡。简单的问题秒回，复杂的问题认真思考。

```
┌─────────────────────────────────────────────┐
│                                             │
│         📐 【图片占位 3】                     │
│                                             │
│      标题：双系统认知路由                     │
│                                             │
│      [线框图：流程图风格]                     │
│                                             │
│      设计要点：                               │
│      - 左侧入口：User Query（用户输入）       │
│      - 中间：Router 模块（类似 CPU 芯片）     │
│      - 上方路径（System 1）：                 │
│        • 绿色，直线                          │
│        • 标注"Fast Path"                     │
│        • 直接通往 Output                      │
│      - 下方路径（System 2）：                 │
│        • 蓝色，有循环结构                    │
│        • 标注"Slow Path"                     │
│        • 经历 Planning → Formatting →        │
│          Observing → Output 的循环           │
│      - 右侧：Output 汇合点                   │
│      - 配色：绿=快（系统1），蓝=慢（系统2）    │
│                                             │
└─────────────────────────────────────────────┘
```

## 四、 记忆：从"文本记录"到"新陈代谢"

在 Agent 的世界里，有一个永恒的焦虑：**Context Window 焦虑**。

对话变长了，怎么办？

传统做法是简单的 FIFO（先进先出）：最早的对话被扔掉。但问题是：**那可能是最重要的信息！**

另一个做法是 RAG（检索增强生成）：把对话存起来，需要时搜索。但 RAG 往往只是死板的搜索，没有真正的"理解"。

### 我们的解法：仿生记忆层级

v0.3.6 借鉴了人脑的记忆机制，设计了 L1-L4 四层架构：

| 层级 | 名称 | 特点 |
|------|------|------|
| L1 | 感官记忆 | 瞬时，容量小，流动快 |
| L2 | 工作记忆 | 缓冲区，主动处理 |
| L3 | 情景记忆 | 事件存储，可检索 |
| L4 | 语义记忆 | 知识沉淀，长期记忆 |

核心创新在于：**记忆不是静态存储，而是"新陈代谢"**。

`Ingest`（摄入）→ `Digest`（消化）→ `Assimilate`（同化）

信息从 L1 进入，经过压缩、提炼、去噪，最终沉淀到 L4。越重要的信息，越会被保留；冗余的信息，会被自然遗忘。

这意味着：Agent 会**越用越懂你**。同时，因为 L2 有自动压缩机制，永远不会"撑爆"上下文窗口。

```
┌─────────────────────────────────────────────┐
│                                             │
│                            │
│                                             │
│      标题：记忆新陈代谢系统                   │
│                                             │
│      [漏斗/层级结构]                  │
│                                             │
│      设计要点：                               │
│      - Top (L1 感官记忆)：                   │
│        • 小，快速流动                        │
│        • 标注"Ingest"                        │
│      - Middle (L2 工作记忆)：                │
│        • 缓冲区                             │
│        • 有 ContextCompressor 图标（挤压机） │
│        • 标注"Digest"                        │
│      - Bottom (L3/L4 长期记忆)：             │
│        • 大型数据库/晶体网格                 │
│        • 标注"Assimilate"                    │
│      - 箭头从上到下，连接各层                │
│      - 配色：从上到下渐变，上层亮、下层深      │
│                                             │
└─────────────────────────────────────────────┘
```

## 五、 神经系统：让 Agent"活"起来

架构再好，用户体验不好也是白搭。

v0.3.6 在细节体验上做了大量优化：

**Tool Streaming**：不仅仅是文本流式输出，而是连"正在调用工具..."的状态变化都是实时的。用户不会盯着黑屏等待，而是能感知到 Agent 在"思考"。

**结构化输出**：利用 Claude/Gemini 的原生结构化输出能力，确保 Agent 之间的机器通信精确无误。不是依赖不稳定的文本解析，而是真正强类型的接口调用。

这些细节让 Agent 应用具备了**生产级的用户体验**。

## 六、 结语：从"构建"到"培育"

Loom v0.3.6 不是一个简单的功能版本，而是我们对"有感知"架构的一次阶段性总结。

我们相信，未来开发 Agent 的方式，将从"构建 Agent"变为"培育 Agent"—— 你不需要写死每一条规则，而是设计好骨架、大脑和记忆系统，让它在与用户的交互中不断"成长"。

**邀请你体验 v0.3.6**

GitHub: https://github.com/kongusen/loom-agent

让我们一起，探索有生命感的代码。

---

> **关于作者**
>
> Loom 是一个实验性的 Agent 框架，致力于探索"生物化"的软件架构。如果你对双系统认知、分形节点、仿生记忆等概念感兴趣，欢迎参与讨论。
