"""
LoomMemory Core Tests

测试记忆系统核心功能，目标覆盖率 90%+
"""

from unittest.mock import AsyncMock, Mock

import pytest

from loom.memory import LoomMemory, MemoryTier, MemoryUnit


class TestLoomMemoryInit:
    """测试 LoomMemory 初始化"""

    def test_init_default(self):
        """测试默认初始化"""
        memory = LoomMemory(node_id="test_node")

        assert memory.node_id == "test_node"
        assert memory.max_l1_size == 50  # 默认值
        assert len(memory._l1_buffer) == 0
        assert len(memory._l2_working) == 0
        assert len(memory._l3_session) == 0

    def test_init_custom_l1_size(self):
        """测试自定义 L1 大小"""
        memory = LoomMemory(node_id="test_node", max_l1_size=100)

        assert memory.max_l1_size == 100

    def test_init_with_vectorization_disabled(self):
        """测试禁用向量化"""
        memory = LoomMemory(
            node_id="test_node",
            enable_l4_vectorization=False
        )

        assert memory.node_id == "test_node"


class TestLoomMemoryL1:
    """测试 L1 (Raw IO) 层操作"""

    def test_add_to_l1(self):
        """测试添加到 L1"""
        memory = LoomMemory(node_id="test_node", max_l1_size=3)

        # 添加单元
        unit1 = MemoryUnit(content="test1", tier=MemoryTier.L1_RAW_IO)
        memory._add_to_l1(unit1)

        assert len(memory._l1_buffer) == 1
        assert memory._l1_buffer[0].content == "test1"

    def test_l1_circular_buffer(self):
        """测试 L1 循环缓冲区"""
        memory = LoomMemory(node_id="test_node", max_l1_size=3)

        # 添加4个单元，应该只保留最后3个
        for i in range(4):
            unit = MemoryUnit(content=f"test{i}", tier=MemoryTier.L1_RAW_IO)
            memory._add_to_l1(unit)

        assert len(memory._l1_buffer) == 3
        # 第一个应该被移除
        contents = [u.content for u in memory._l1_buffer]
        assert "test0" not in contents
        assert "test1" in contents
        assert "test2" in contents
        assert "test3" in contents

    def test_get_l1_all(self):
        """测试获取所有 L1 单元"""
        memory = LoomMemory(node_id="test_node")

        # 添加单元
        for i in range(3):
            unit = MemoryUnit(content=f"test{i}", tier=MemoryTier.L1_RAW_IO)
            memory._add_to_l1(unit)

        units = memory.get_l1()
        assert len(units) == 3

    def test_get_l1_with_limit(self):
        """测试获取限制数量的 L1 单元"""
        memory = LoomMemory(node_id="test_node")

        # 添加单元
        for i in range(5):
            unit = MemoryUnit(content=f"test{i}", tier=MemoryTier.L1_RAW_IO)
            memory._add_to_l1(unit)

        units = memory.get_l1(limit=2)
        assert len(units) == 2


class TestLoomMemoryL2:
    """测试 L2 (Working) 层操作"""

    def test_add_to_l2(self):
        """测试添加到 L2"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(
            id="unit1",
            content="test content",
            tier=MemoryTier.L2_WORKING
        )
        memory._add_to_l2(unit)

        assert len(memory._l2_working) == 1
        assert memory._l2_working[0].content == "test content"

    def test_get_l2(self):
        """测试获取 L2 单元"""
        memory = LoomMemory(node_id="test_node")

        # 添加多个单元
        for i in range(3):
            unit = MemoryUnit(
                id=f"unit{i}",
                content=f"test{i}",
                tier=MemoryTier.L2_WORKING
            )
            memory._add_to_l2(unit)

        units = memory.get_l2()
        assert len(units) == 3

    def test_clear_l2(self):
        """测试清空 L2"""
        memory = LoomMemory(node_id="test_node")

        # 添加单元
        unit = MemoryUnit(
            id="unit1",
            content="test",
            tier=MemoryTier.L2_WORKING
        )
        memory._add_to_l2(unit)

        assert len(memory._l2_working) == 1

        # 清空
        memory.clear_l2()
        assert len(memory._l2_working) == 0


class TestLoomMemoryL3:
    """测试 L3 (Session) 层操作"""

    def test_add_to_l3(self):
        """测试添加到 L3"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(
            content="test content",
            tier=MemoryTier.L3_SESSION
        )
        memory._add_to_l3(unit, session_id="session1")

        units = memory.get_l3(session_id="session1")
        assert len(units) == 1
        assert units[0].content == "test content"

    def test_get_l3_default_session(self):
        """测试获取默认会话的 L3 单元"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(content="test", tier=MemoryTier.L3_SESSION)
        memory._add_to_l3(unit)  # 使用默认 session_id

        units = memory.get_l3()
        assert len(units) == 1

    def test_clear_l3(self):
        """测试清空 L3"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(content="test", tier=MemoryTier.L3_SESSION)
        memory._add_to_l3(unit, session_id="session1")

        assert len(memory.get_l3(session_id="session1")) == 1

        memory.clear_l3(session_id="session1")
        assert len(memory.get_l3(session_id="session1")) == 0


class TestLoomMemoryGeneral:
    """测试通用操作"""

    def test_get_by_id(self):
        """测试通过 ID 获取单元"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(
            id="test_id",
            content="test content",
            tier=MemoryTier.L2_WORKING
        )
        memory._add_to_l2(unit)
        memory._id_index[unit.id] = unit  # 手动添加到索引

        retrieved = memory.get("test_id")
        assert retrieved is not None
        assert retrieved.content == "test content"

    def test_get_nonexistent(self):
        """测试获取不存在的单元"""
        memory = LoomMemory(node_id="test_node")

        retrieved = memory.get("nonexistent_id")
        assert retrieved is None

    def test_get_stats(self):
        """测试获取统计信息"""
        memory = LoomMemory(node_id="test_node")

        # 添加一些单元
        memory._add_to_l1(MemoryUnit(content="l1", tier=MemoryTier.L1_RAW_IO))
        memory._add_to_l2(MemoryUnit(id="l2", content="l2", tier=MemoryTier.L2_WORKING))

        stats = memory.get_stats()
        assert "l1_size" in stats
        assert "l2_size" in stats
        assert stats["l1_size"] == 1
        assert stats["l2_size"] == 1

    def test_clear_all(self):
        """测试清空所有层"""
        memory = LoomMemory(node_id="test_node")

        # 添加到各层
        memory._add_to_l1(MemoryUnit(content="l1", tier=MemoryTier.L1_RAW_IO))
        memory._add_to_l2(MemoryUnit(id="l2", content="l2", tier=MemoryTier.L2_WORKING))
        memory._add_to_l3(MemoryUnit(content="l3", tier=MemoryTier.L3_SESSION))

        # 清空所有
        memory.clear_all()

        assert len(memory._l1_buffer) == 0
        assert len(memory._l2_working) == 0
        assert len(memory._l3_session) == 0


class TestLoomMemoryL4:
    """测试 L4 (Global) 层操作"""

    @pytest.mark.asyncio
    async def test_add_to_l4_without_vectorization(self):
        """测试添加到 L4（不启用向量化）"""
        memory = LoomMemory(node_id="test_node", enable_l4_vectorization=False)

        unit = MemoryUnit(
            id="l4_unit",
            content="global knowledge",
            tier=MemoryTier.L4_GLOBAL
        )
        await memory._add_to_l4(unit)

        assert len(memory._l4_global) == 1
        assert memory._l4_global[0].content == "global knowledge"

    def test_get_l4(self):
        """测试获取 L4 单元"""
        memory = LoomMemory(node_id="test_node")

        # 直接添加到 L4（绕过 async）
        unit = MemoryUnit(id="l4_1", content="test", tier=MemoryTier.L4_GLOBAL)
        memory._l4_global.append(unit)

        units = memory.get_l4()
        assert len(units) == 1
        assert units[0].content == "test"

    def test_simple_search_l4(self):
        """测试 L4 简单文本搜索"""
        memory = LoomMemory(node_id="test_node")

        # 添加多个单元
        memory._l4_global.append(
            MemoryUnit(id="1", content="Python programming", tier=MemoryTier.L4_GLOBAL, importance=0.9)
        )
        memory._l4_global.append(
            MemoryUnit(id="2", content="Java development", tier=MemoryTier.L4_GLOBAL, importance=0.7)
        )
        memory._l4_global.append(
            MemoryUnit(id="3", content="Python data science", tier=MemoryTier.L4_GLOBAL, importance=0.8)
        )

        # 搜索 "Python"
        results = memory._simple_search_l4("Python", limit=2)
        assert len(results) == 2
        # 应该按重要性排序
        assert results[0].importance == 0.9
        assert results[1].importance == 0.8


class TestLoomMemoryAdd:
    """测试统一的 add() 接口"""

    @pytest.mark.asyncio
    async def test_add_l1_unit(self):
        """测试通过 add() 添加 L1 单元"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(id="test1", content="test", tier=MemoryTier.L1_RAW_IO)
        unit_id = await memory.add(unit)

        assert unit_id == "test1"
        assert len(memory._l1_buffer) == 1
        assert memory._id_index["test1"] == unit

    @pytest.mark.asyncio
    async def test_add_l2_unit(self):
        """测试通过 add() 添加 L2 单元"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(id="test2", content="test", tier=MemoryTier.L2_WORKING)
        unit_id = await memory.add(unit)

        assert unit_id == "test2"
        assert len(memory._l2_working) == 1
        assert memory._id_index["test2"] == unit

    @pytest.mark.asyncio
    async def test_add_l3_unit(self):
        """测试通过 add() 添加 L3 单元"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(
            id="test3",
            content="test",
            tier=MemoryTier.L3_SESSION,
            metadata={"session_id": "session1"}
        )
        unit_id = await memory.add(unit)

        assert unit_id == "test3"
        assert len(memory.get_l3(session_id="session1")) == 1
        assert memory._id_index["test3"] == unit

    @pytest.mark.asyncio
    async def test_add_l4_unit(self):
        """测试通过 add() 添加 L4 单元"""
        memory = LoomMemory(node_id="test_node", enable_l4_vectorization=False)

        unit = MemoryUnit(id="test4", content="test", tier=MemoryTier.L4_GLOBAL)
        unit_id = await memory.add(unit)

        assert unit_id == "test4"
        assert len(memory._l4_global) == 1
        assert memory._id_index["test4"] == unit


class TestLoomMemoryTokenCounting:
    """测试 Token 计数功能"""

    def test_estimate_tokens(self):
        """测试 token 估算"""
        memory = LoomMemory(node_id="test_node")

        # 创建一个包含 40 个字符的单元（估算应该是 10 tokens）
        unit = MemoryUnit(content="a" * 40, tier=MemoryTier.L1_RAW_IO)
        tokens = memory._estimate_tokens(unit)

        assert tokens == 10  # 40 / 4 = 10

    def test_count_tokens_without_counter(self):
        """测试不使用 token counter 的计数（使用估算）"""
        memory = LoomMemory(node_id="test_node")

        unit = MemoryUnit(content="test content", tier=MemoryTier.L1_RAW_IO)
        tokens = memory._count_tokens(unit, token_counter=None)

        # 应该使用估算：len("test content") / 4 = 12 / 4 = 3
        assert tokens == 3


class TestLoomMemoryContextBuilding:
    """测试上下文构建功能"""

    @pytest.mark.asyncio
    async def test_build_context_empty(self):
        """测试空记忆的上下文构建"""
        memory = LoomMemory(node_id="test_node")

        context = await memory.build_context()
        assert len(context) == 0

    @pytest.mark.asyncio
    async def test_build_context_with_l1_l2(self):
        """测试包含 L1 和 L2 的上下文构建"""
        memory = LoomMemory(node_id="test_node")

        # 添加 L1 单元
        l1_unit = MemoryUnit(id="l1", content="L1 content", tier=MemoryTier.L1_RAW_IO)
        memory._add_to_l1(l1_unit)

        # 添加 L2 单元
        l2_unit = MemoryUnit(id="l2", content="L2 content", tier=MemoryTier.L2_WORKING)
        memory._add_to_l2(l2_unit)

        context = await memory.build_context(max_tokens=1000)

        # 应该包含 L1 和 L2
        assert len(context) >= 2
        contents = [u.content for u in context]
        assert "L1 content" in contents
        assert "L2 content" in contents

    @pytest.mark.asyncio
    async def test_build_context_with_token_limit(self):
        """测试带 token 限制的上下文构建"""
        memory = LoomMemory(node_id="test_node")

        # 添加多个单元
        for i in range(10):
            unit = MemoryUnit(id=f"unit{i}", content="x" * 100, tier=MemoryTier.L1_RAW_IO)
            memory._add_to_l1(unit)

        # 使用很小的 token 限制
        context = await memory.build_context(max_tokens=50)

        # 应该只包含部分单元
        assert len(context) < 10

    @pytest.mark.asyncio
    async def test_build_context_with_l3(self):
        """测试包含 L3 的上下文构建"""
        memory = LoomMemory(node_id="test_node")

        # 添加 L3 单元
        for i in range(5):
            unit = MemoryUnit(id=f"l3_{i}", content=f"L3 content {i}", tier=MemoryTier.L3_SESSION)
            memory._add_to_l3(unit, session_id="test_session")

        context = await memory.build_context(max_tokens=1000, session_id="test_session")

        # 应该包含 L3 单元
        assert len(context) > 0


class TestLoomMemoryWithMocks:
    """测试带 Mock 组件的记忆功能"""

    @pytest.mark.asyncio
    async def test_add_to_l4_with_vectorization(self):
        """测试带向量化的 L4 添加"""
        memory = LoomMemory(node_id="test_node", enable_l4_vectorization=True)

        # Mock embedding provider
        memory.embedding_provider = Mock()
        memory.embedding_provider.embed = AsyncMock(return_value=[0.1, 0.2, 0.3])

        # Mock vector store
        memory.vector_store = Mock()
        memory.vector_store.add = AsyncMock()

        unit = MemoryUnit(id="l4_vec", content="test content", tier=MemoryTier.L4_GLOBAL)
        await memory._add_to_l4(unit)

        # 验证向量化被调用
        memory.embedding_provider.embed.assert_called_once()
        memory.vector_store.add.assert_called_once()

    @pytest.mark.asyncio
    async def test_add_to_l4_with_compression(self):
        """测试带压缩的 L4 添加"""
        memory = LoomMemory(node_id="test_node", enable_l4_vectorization=False)

        # Mock compressor
        memory.l4_compressor = Mock()
        memory.l4_compressor.should_compress = AsyncMock(return_value=True)
        memory.l4_compressor.compress = AsyncMock(return_value=[
            MemoryUnit(id="compressed", content="compressed", tier=MemoryTier.L4_GLOBAL)
        ])

        unit = MemoryUnit(id="l4_comp", content="test", tier=MemoryTier.L4_GLOBAL)
        await memory._add_to_l4(unit)

        # 验证压缩被调用
        memory.l4_compressor.should_compress.assert_called_once()
        memory.l4_compressor.compress.assert_called_once()

    @pytest.mark.asyncio
    async def test_search_l4_with_vector_store(self):
        """测试带向量存储的 L4 搜索"""
        memory = LoomMemory(node_id="test_node")

        # 添加单元到索引
        unit = MemoryUnit(id="search_unit", content="test", tier=MemoryTier.L4_GLOBAL)
        memory._id_index["search_unit"] = unit

        # Mock components
        memory.embedding_provider = Mock()
        memory.embedding_provider.embed = AsyncMock(return_value=[0.1, 0.2])

        memory.vector_store = Mock()
        memory.vector_store.search = AsyncMock(return_value=[{"id": "search_unit", "score": 0.9}])

        results = await memory.search_l4("test query", limit=5)

        # 验证搜索被调用
        memory.embedding_provider.embed.assert_called_once_with("test query")
        memory.vector_store.search.assert_called_once()
        assert len(results) == 1
        assert results[0].id == "search_unit"

    def test_count_tokens_with_counter(self):
        """测试使用 token counter 的计数"""
        memory = LoomMemory(node_id="test_node")

        # Mock token counter
        token_counter = Mock()
        token_counter.count = Mock(return_value=42)

        unit = MemoryUnit(content="test content", tier=MemoryTier.L1_RAW_IO)
        tokens = memory._count_tokens(unit, token_counter=token_counter)

        # 应该使用 token counter
        token_counter.count.assert_called_once()
        assert tokens == 42
