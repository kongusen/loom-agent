# 公理系统 (Axiomatic System)

## 定义

Loom 框架建立在 **5 条基础公理** 之上，这些公理构成了系统的理论基础，确保所有设计决策的逻辑一致性和可预测性。

## 核心思想

传统 Agent 框架往往采用"实用主义"设计 —— 遇到问题就打补丁，导致系统逐渐变得复杂且不可预测。Loom 采用不同的方法：从**第一性原理**出发，建立严格的公理系统，然后通过逻辑推导得到所有设计决策。

这种方法的好处是：
- **可预测性**: 系统行为可以从前置条件推导出来
- **可扩展性**: 新功能可以在不违反公理的前提下添加
- **可验证性**: 设计决策的正确性可以被证明

## 五条公理

### A1: 统一接口公理 (Unified Interface)

> **所有组件必须实现相同的接口协议，确保可组合性。**

**含义**: Agent、Tool、Memory、Workflow 等所有组件都是"节点"，遵循相同的生命周期和调用协议。

**推导**:
- 所有组件都可以用 `CompositeNode` 组合
- 分形架构得以实现

**相关概念**: [协议优先](Protocol-First) | [分形递归](Fractal-Recursion)

---

### A2: 事件主权公理 (Event Sovereignty)

> **每个节点拥有其事件的完全主权，可观测但不被干预。**

**含义**: 节点发布的事件是其内部状态的真实反映，外部可以订阅观测，但不能修改或阻止事件发布。

**推导**:
- 可观测性是内置的，不是事后添加的
- 事件总线是解耦的，不包含业务逻辑

**相关概念**: [事件总线](Event-Bus) | [可观测性](Observability)

---

### A3: 分形递归公理 (Fractal Recursion)

> **任意层级的节点组合，在行为上与单个节点完全一致。**

**含义**: 一个由多个 Agent 组成的"团队"，对外表现为一个单一的 Agent。可以无限递归组合。

**推导**:
- 复杂度始终是 O(1)，无论组合多深
- 系统可以无限扩展而不增加认知负载

**相关概念**: [分形架构](Fractal-Architecture) | [组合节点](Composite-Node)

---

### A4: 记忆代谢公理 (Memory Metabolism)

> **记忆像生物代谢一样，经历摄入、消化、同化、排泄的循环过程。**

**含义**: 信息不是简单存储，而是经过处理、提炼、整合后进入长期记忆。

**推导**:
- L1→L2→L3→L4 的记忆分层
- 自动化的记忆提炼和压缩机制

**相关概念**: [代谢记忆](Metabolic-Memory) | [记忆分层](Memory-Layers)

---

### A5: 自主决策公理 (Autonomous Decision)

> **Agent 根据任务自主决定使用哪些能力（反思/工具/规划/协作）。**

**含义**: 不是外部告诉 Agent "现在使用工具"，而是 Agent 自己判断需要什么能力。

**推导**:
- 四范式工作模式
- LLM 的工具调用自动决策

**相关概念**: [四范式工作](Four-Paradigms) | [自主能力](Autonomous-Capabilities)

---

## 公理间的关系

```
A1 (统一接口)
       ↓
       ├─→ A3 (分形递归) ──→ [分形架构]
       │
A2 (事件主权)
       ↓
       └─→ A5 (自主决策) ──→ [四范式工作]

A4 (记忆代谢) ──→ [代谢记忆]
```

## 参见

- 📖 [设计文档](design/Axiomatic-System)
- 🔧 [API 指南]: [创建符合公理的 Agent](api/Agent)
- 💡 [示例代码]: [公理系统演示](examples/axiomatic-demo)

## 代码位置

- 公理定义: `loom/concepts/axioms.py`
- 协议接口: `loom/protocol/`

## 反向链接

被引用于: [分形架构](Fractal-Architecture) | [事件总线](Event-Bus) | [代谢记忆](Metabolic-Memory) | [四范式工作](Four-Paradigms)
